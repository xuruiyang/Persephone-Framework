# Generated from .\persephone.g4 by ANTLR 4.8
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3!")
        buf.write("\u00d2\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\3\2\3\2\3\2\3\2\3")
        buf.write("\3\3\3\3\3\7\3*\n\3\f\3\16\3-\13\3\3\4\3\4\3\4\5\4\62")
        buf.write("\n\4\3\5\3\5\3\5\3\5\3\5\3\5\7\5:\n\5\f\5\16\5=\13\5\3")
        buf.write("\5\3\5\3\5\3\5\3\6\3\6\3\6\3\6\3\6\3\6\7\6I\n\6\f\6\16")
        buf.write("\6L\13\6\3\6\3\6\3\6\3\6\3\7\3\7\3\7\3\7\3\7\3\7\7\7X")
        buf.write("\n\7\f\7\16\7[\13\7\3\7\3\7\3\7\3\7\3\b\3\b\3\b\3\b\3")
        buf.write("\b\3\b\7\bg\n\b\f\b\16\bj\13\b\3\b\3\b\3\t\3\t\3\t\3\t")
        buf.write("\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3")
        buf.write("\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\7\t\u0088\n\t\f\t\16")
        buf.write("\t\u008b\13\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t\3\t")
        buf.write("\3\t\3\t\3\t\5\t\u009a\n\t\3\n\3\n\3\n\3\n\3\n\3\n\3\n")
        buf.write("\3\n\5\n\u00a4\n\n\3\13\3\13\3\13\3\13\3\13\3\13\3\13")
        buf.write("\3\13\3\13\3\13\3\13\3\13\3\13\3\13\5\13\u00b4\n\13\3")
        buf.write("\f\3\f\3\r\3\r\3\16\3\16\3\16\3\16\5\16\u00be\n\16\3\16")
        buf.write("\5\16\u00c1\n\16\3\16\3\16\3\16\3\16\3\16\3\16\3\16\5")
        buf.write("\16\u00ca\n\16\3\17\3\17\3\20\3\20\3\21\3\21\3\21\2\2")
        buf.write("\22\2\4\6\b\n\f\16\20\22\24\26\30\32\34\36 \2\6\3\2\17")
        buf.write("\20\3\2\21\25\3\2\5\6\3\2\r\16\2\u00d5\2\"\3\2\2\2\4&")
        buf.write("\3\2\2\2\6\61\3\2\2\2\b\63\3\2\2\2\nB\3\2\2\2\fQ\3\2\2")
        buf.write("\2\16`\3\2\2\2\20\u0099\3\2\2\2\22\u00a3\3\2\2\2\24\u00b3")
        buf.write("\3\2\2\2\26\u00b5\3\2\2\2\30\u00b7\3\2\2\2\32\u00c9\3")
        buf.write("\2\2\2\34\u00cb\3\2\2\2\36\u00cd\3\2\2\2 \u00cf\3\2\2")
        buf.write("\2\"#\5\4\3\2#$\5\16\b\2$%\7\2\2\3%\3\3\2\2\2&\'\7\30")
        buf.write("\2\2\'+\5\6\4\2(*\5\6\4\2)(\3\2\2\2*-\3\2\2\2+)\3\2\2")
        buf.write("\2+,\3\2\2\2,\5\3\2\2\2-+\3\2\2\2.\62\5\b\5\2/\62\5\n")
        buf.write("\6\2\60\62\5\f\7\2\61.\3\2\2\2\61/\3\2\2\2\61\60\3\2\2")
        buf.write("\2\62\7\3\2\2\2\63\64\7\31\2\2\64\65\7\37\2\2\65\66\7")
        buf.write("\7\2\2\66;\7 \2\2\678\7\t\2\28:\7 \2\29\67\3\2\2\2:=\3")
        buf.write("\2\2\2;9\3\2\2\2;<\3\2\2\2<>\3\2\2\2=;\3\2\2\2>?\7\b\2")
        buf.write("\2?@\7\n\2\2@A\5\20\t\2A\t\3\2\2\2BC\7\32\2\2CD\7\37\2")
        buf.write("\2DE\7\7\2\2EJ\7 \2\2FG\7\t\2\2GI\7 \2\2HF\3\2\2\2IL\3")
        buf.write("\2\2\2JH\3\2\2\2JK\3\2\2\2KM\3\2\2\2LJ\3\2\2\2MN\7\b\2")
        buf.write("\2NO\7\n\2\2OP\5\20\t\2P\13\3\2\2\2QR\7\33\2\2RS\7\37")
        buf.write("\2\2ST\7\7\2\2TY\7 \2\2UV\7\t\2\2VX\7 \2\2WU\3\2\2\2X")
        buf.write("[\3\2\2\2YW\3\2\2\2YZ\3\2\2\2Z\\\3\2\2\2[Y\3\2\2\2\\]")
        buf.write("\7\b\2\2]^\7\n\2\2^_\5\20\t\2_\r\3\2\2\2`a\7\34\2\2ab")
        buf.write("\7\37\2\2bc\7\7\2\2ch\5\32\16\2de\7\t\2\2eg\5\32\16\2")
        buf.write("fd\3\2\2\2gj\3\2\2\2hf\3\2\2\2hi\3\2\2\2ik\3\2\2\2jh\3")
        buf.write("\2\2\2kl\7\b\2\2l\17\3\2\2\2mn\5\36\20\2no\7\7\2\2op\7")
        buf.write(" \2\2pq\7\t\2\2qr\5\22\n\2rs\7\t\2\2st\5\20\t\2tu\7\b")
        buf.write("\2\2u\u009a\3\2\2\2vw\5 \21\2wx\7\7\2\2xy\5\20\t\2yz\7")
        buf.write("\t\2\2z{\5\20\t\2{|\7\b\2\2|\u009a\3\2\2\2}~\7\f\2\2~")
        buf.write("\177\7\7\2\2\177\u0080\5\20\t\2\u0080\u0081\7\b\2\2\u0081")
        buf.write("\u009a\3\2\2\2\u0082\u0083\7\37\2\2\u0083\u0084\7\7\2")
        buf.write("\2\u0084\u0089\5\32\16\2\u0085\u0086\7\t\2\2\u0086\u0088")
        buf.write("\5\32\16\2\u0087\u0085\3\2\2\2\u0088\u008b\3\2\2\2\u0089")
        buf.write("\u0087\3\2\2\2\u0089\u008a\3\2\2\2\u008a\u008c\3\2\2\2")
        buf.write("\u008b\u0089\3\2\2\2\u008c\u008d\7\b\2\2\u008d\u009a\3")
        buf.write("\2\2\2\u008e\u008f\7\13\2\2\u008f\u0090\7\7\2\2\u0090")
        buf.write("\u0091\5\24\13\2\u0091\u0092\7\t\2\2\u0092\u0093\5\20")
        buf.write("\t\2\u0093\u0094\7\t\2\2\u0094\u0095\5\20\t\2\u0095\u0096")
        buf.write("\7\b\2\2\u0096\u009a\3\2\2\2\u0097\u009a\7\26\2\2\u0098")
        buf.write("\u009a\7\27\2\2\u0099m\3\2\2\2\u0099v\3\2\2\2\u0099}\3")
        buf.write("\2\2\2\u0099\u0082\3\2\2\2\u0099\u008e\3\2\2\2\u0099\u0097")
        buf.write("\3\2\2\2\u0099\u0098\3\2\2\2\u009a\21\3\2\2\2\u009b\u009c")
        buf.write("\7\4\2\2\u009c\u009d\7\7\2\2\u009d\u009e\5\32\16\2\u009e")
        buf.write("\u009f\7\t\2\2\u009f\u00a0\5\32\16\2\u00a0\u00a1\7\b\2")
        buf.write("\2\u00a1\u00a4\3\2\2\2\u00a2\u00a4\7\3\2\2\u00a3\u009b")
        buf.write("\3\2\2\2\u00a3\u00a2\3\2\2\2\u00a4\23\3\2\2\2\u00a5\u00a6")
        buf.write("\5\30\r\2\u00a6\u00a7\7\7\2\2\u00a7\u00a8\5\32\16\2\u00a8")
        buf.write("\u00a9\7\t\2\2\u00a9\u00aa\5\32\16\2\u00aa\u00ab\7\b\2")
        buf.write("\2\u00ab\u00b4\3\2\2\2\u00ac\u00ad\5\26\f\2\u00ad\u00ae")
        buf.write("\7\7\2\2\u00ae\u00af\5\24\13\2\u00af\u00b0\7\t\2\2\u00b0")
        buf.write("\u00b1\5\24\13\2\u00b1\u00b2\7\b\2\2\u00b2\u00b4\3\2\2")
        buf.write("\2\u00b3\u00a5\3\2\2\2\u00b3\u00ac\3\2\2\2\u00b4\25\3")
        buf.write("\2\2\2\u00b5\u00b6\t\2\2\2\u00b6\27\3\2\2\2\u00b7\u00b8")
        buf.write("\t\3\2\2\u00b8\31\3\2\2\2\u00b9\u00ca\7!\2\2\u00ba\u00c0")
        buf.write("\7 \2\2\u00bb\u00bd\7\7\2\2\u00bc\u00be\7 \2\2\u00bd\u00bc")
        buf.write("\3\2\2\2\u00bd\u00be\3\2\2\2\u00be\u00bf\3\2\2\2\u00bf")
        buf.write("\u00c1\7\b\2\2\u00c0\u00bb\3\2\2\2\u00c0\u00c1\3\2\2\2")
        buf.write("\u00c1\u00ca\3\2\2\2\u00c2\u00c3\5\34\17\2\u00c3\u00c4")
        buf.write("\7\7\2\2\u00c4\u00c5\5\32\16\2\u00c5\u00c6\7\t\2\2\u00c6")
        buf.write("\u00c7\5\32\16\2\u00c7\u00c8\7\b\2\2\u00c8\u00ca\3\2\2")
        buf.write("\2\u00c9\u00b9\3\2\2\2\u00c9\u00ba\3\2\2\2\u00c9\u00c2")
        buf.write("\3\2\2\2\u00ca\33\3\2\2\2\u00cb\u00cc\t\4\2\2\u00cc\35")
        buf.write("\3\2\2\2\u00cd\u00ce\t\5\2\2\u00ce\37\3\2\2\2\u00cf\u00d0")
        buf.write("\t\2\2\2\u00d0!\3\2\2\2\17+\61;JYh\u0089\u0099\u00a3\u00b3")
        buf.write("\u00bd\u00c0\u00c9")
        return buf.getvalue()


class persephoneParser ( Parser ):

    grammarFileName = "persephone.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'s.getActions()'", "'Domain'", "'Add'", 
                     "'Sub'", "'('", "')'", "','", "'='", "'ITE'", "'Not'", 
                     "'Forall'", "'Exists'", "'Or'", "'And'", "'EQ'", "'GE'", 
                     "'LE'", "'GT'", "'LS'", "'TRUE'", "'FALSE'", "'GAME'", 
                     "'PREDICATE'", "'GFP'", "'LFP'", "'PLAY'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "DOM", "Add", "Sub", "LPAREN", 
                      "RPAREN", "SEPARATOR", "EQUAL", "ITE", "NOT", "FORALL", 
                      "EXISTS", "OR", "AND", "EQ", "GE", "LE", "GT", "LS", 
                      "TRUE", "FALSE", "GAME", "PREDICATE", "GFP", "LFP", 
                      "PLAY", "ENDLINE", "WHITESPACE", "PRED_CONST", "VAR", 
                      "NUM" ]

    RULE_main = 0
    RULE_game_definition = 1
    RULE_super_predicate_definition = 2
    RULE_predicate_definition = 3
    RULE_gfp_definition = 4
    RULE_lfp_definition = 5
    RULE_game_play = 6
    RULE_formula = 7
    RULE_domain = 8
    RULE_cond = 9
    RULE_alg_bin_op = 10
    RULE_comp_op = 11
    RULE_term = 12
    RULE_algebra = 13
    RULE_quantifier = 14
    RULE_bin_op = 15

    ruleNames =  [ "main", "game_definition", "super_predicate_definition", 
                   "predicate_definition", "gfp_definition", "lfp_definition", 
                   "game_play", "formula", "domain", "cond", "alg_bin_op", 
                   "comp_op", "term", "algebra", "quantifier", "bin_op" ]

    EOF = Token.EOF
    T__0=1
    DOM=2
    Add=3
    Sub=4
    LPAREN=5
    RPAREN=6
    SEPARATOR=7
    EQUAL=8
    ITE=9
    NOT=10
    FORALL=11
    EXISTS=12
    OR=13
    AND=14
    EQ=15
    GE=16
    LE=17
    GT=18
    LS=19
    TRUE=20
    FALSE=21
    GAME=22
    PREDICATE=23
    GFP=24
    LFP=25
    PLAY=26
    ENDLINE=27
    WHITESPACE=28
    PRED_CONST=29
    VAR=30
    NUM=31

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.8")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class MainContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def game_definition(self):
            return self.getTypedRuleContext(persephoneParser.Game_definitionContext,0)


        def game_play(self):
            return self.getTypedRuleContext(persephoneParser.Game_playContext,0)


        def EOF(self):
            return self.getToken(persephoneParser.EOF, 0)

        def getRuleIndex(self):
            return persephoneParser.RULE_main

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMain" ):
                listener.enterMain(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMain" ):
                listener.exitMain(self)




    def main(self):

        localctx = persephoneParser.MainContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_main)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 32
            self.game_definition()
            self.state = 33
            self.game_play()
            self.state = 34
            self.match(persephoneParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Game_definitionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GAME(self):
            return self.getToken(persephoneParser.GAME, 0)

        def super_predicate_definition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(persephoneParser.Super_predicate_definitionContext)
            else:
                return self.getTypedRuleContext(persephoneParser.Super_predicate_definitionContext,i)


        def getRuleIndex(self):
            return persephoneParser.RULE_game_definition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGame_definition" ):
                listener.enterGame_definition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGame_definition" ):
                listener.exitGame_definition(self)




    def game_definition(self):

        localctx = persephoneParser.Game_definitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_game_definition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 36
            self.match(persephoneParser.GAME)
            self.state = 37
            self.super_predicate_definition()
            self.state = 41
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << persephoneParser.PREDICATE) | (1 << persephoneParser.GFP) | (1 << persephoneParser.LFP))) != 0):
                self.state = 38
                self.super_predicate_definition()
                self.state = 43
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Super_predicate_definitionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def predicate_definition(self):
            return self.getTypedRuleContext(persephoneParser.Predicate_definitionContext,0)


        def gfp_definition(self):
            return self.getTypedRuleContext(persephoneParser.Gfp_definitionContext,0)


        def lfp_definition(self):
            return self.getTypedRuleContext(persephoneParser.Lfp_definitionContext,0)


        def getRuleIndex(self):
            return persephoneParser.RULE_super_predicate_definition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSuper_predicate_definition" ):
                listener.enterSuper_predicate_definition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSuper_predicate_definition" ):
                listener.exitSuper_predicate_definition(self)




    def super_predicate_definition(self):

        localctx = persephoneParser.Super_predicate_definitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_super_predicate_definition)
        try:
            self.state = 47
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [persephoneParser.PREDICATE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 44
                self.predicate_definition()
                pass
            elif token in [persephoneParser.GFP]:
                self.enterOuterAlt(localctx, 2)
                self.state = 45
                self.gfp_definition()
                pass
            elif token in [persephoneParser.LFP]:
                self.enterOuterAlt(localctx, 3)
                self.state = 46
                self.lfp_definition()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Predicate_definitionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PREDICATE(self):
            return self.getToken(persephoneParser.PREDICATE, 0)

        def PRED_CONST(self):
            return self.getToken(persephoneParser.PRED_CONST, 0)

        def LPAREN(self):
            return self.getToken(persephoneParser.LPAREN, 0)

        def VAR(self, i:int=None):
            if i is None:
                return self.getTokens(persephoneParser.VAR)
            else:
                return self.getToken(persephoneParser.VAR, i)

        def RPAREN(self):
            return self.getToken(persephoneParser.RPAREN, 0)

        def EQUAL(self):
            return self.getToken(persephoneParser.EQUAL, 0)

        def formula(self):
            return self.getTypedRuleContext(persephoneParser.FormulaContext,0)


        def SEPARATOR(self, i:int=None):
            if i is None:
                return self.getTokens(persephoneParser.SEPARATOR)
            else:
                return self.getToken(persephoneParser.SEPARATOR, i)

        def getRuleIndex(self):
            return persephoneParser.RULE_predicate_definition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPredicate_definition" ):
                listener.enterPredicate_definition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPredicate_definition" ):
                listener.exitPredicate_definition(self)




    def predicate_definition(self):

        localctx = persephoneParser.Predicate_definitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_predicate_definition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 49
            self.match(persephoneParser.PREDICATE)
            self.state = 50
            self.match(persephoneParser.PRED_CONST)
            self.state = 51
            self.match(persephoneParser.LPAREN)
            self.state = 52
            self.match(persephoneParser.VAR)
            self.state = 57
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==persephoneParser.SEPARATOR:
                self.state = 53
                self.match(persephoneParser.SEPARATOR)
                self.state = 54
                self.match(persephoneParser.VAR)
                self.state = 59
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 60
            self.match(persephoneParser.RPAREN)
            self.state = 61
            self.match(persephoneParser.EQUAL)
            self.state = 62
            self.formula()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Gfp_definitionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GFP(self):
            return self.getToken(persephoneParser.GFP, 0)

        def PRED_CONST(self):
            return self.getToken(persephoneParser.PRED_CONST, 0)

        def LPAREN(self):
            return self.getToken(persephoneParser.LPAREN, 0)

        def VAR(self, i:int=None):
            if i is None:
                return self.getTokens(persephoneParser.VAR)
            else:
                return self.getToken(persephoneParser.VAR, i)

        def RPAREN(self):
            return self.getToken(persephoneParser.RPAREN, 0)

        def EQUAL(self):
            return self.getToken(persephoneParser.EQUAL, 0)

        def formula(self):
            return self.getTypedRuleContext(persephoneParser.FormulaContext,0)


        def SEPARATOR(self, i:int=None):
            if i is None:
                return self.getTokens(persephoneParser.SEPARATOR)
            else:
                return self.getToken(persephoneParser.SEPARATOR, i)

        def getRuleIndex(self):
            return persephoneParser.RULE_gfp_definition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGfp_definition" ):
                listener.enterGfp_definition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGfp_definition" ):
                listener.exitGfp_definition(self)




    def gfp_definition(self):

        localctx = persephoneParser.Gfp_definitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_gfp_definition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 64
            self.match(persephoneParser.GFP)
            self.state = 65
            self.match(persephoneParser.PRED_CONST)
            self.state = 66
            self.match(persephoneParser.LPAREN)
            self.state = 67
            self.match(persephoneParser.VAR)
            self.state = 72
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==persephoneParser.SEPARATOR:
                self.state = 68
                self.match(persephoneParser.SEPARATOR)
                self.state = 69
                self.match(persephoneParser.VAR)
                self.state = 74
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 75
            self.match(persephoneParser.RPAREN)
            self.state = 76
            self.match(persephoneParser.EQUAL)
            self.state = 77
            self.formula()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Lfp_definitionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LFP(self):
            return self.getToken(persephoneParser.LFP, 0)

        def PRED_CONST(self):
            return self.getToken(persephoneParser.PRED_CONST, 0)

        def LPAREN(self):
            return self.getToken(persephoneParser.LPAREN, 0)

        def VAR(self, i:int=None):
            if i is None:
                return self.getTokens(persephoneParser.VAR)
            else:
                return self.getToken(persephoneParser.VAR, i)

        def RPAREN(self):
            return self.getToken(persephoneParser.RPAREN, 0)

        def EQUAL(self):
            return self.getToken(persephoneParser.EQUAL, 0)

        def formula(self):
            return self.getTypedRuleContext(persephoneParser.FormulaContext,0)


        def SEPARATOR(self, i:int=None):
            if i is None:
                return self.getTokens(persephoneParser.SEPARATOR)
            else:
                return self.getToken(persephoneParser.SEPARATOR, i)

        def getRuleIndex(self):
            return persephoneParser.RULE_lfp_definition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLfp_definition" ):
                listener.enterLfp_definition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLfp_definition" ):
                listener.exitLfp_definition(self)




    def lfp_definition(self):

        localctx = persephoneParser.Lfp_definitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_lfp_definition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 79
            self.match(persephoneParser.LFP)
            self.state = 80
            self.match(persephoneParser.PRED_CONST)
            self.state = 81
            self.match(persephoneParser.LPAREN)
            self.state = 82
            self.match(persephoneParser.VAR)
            self.state = 87
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==persephoneParser.SEPARATOR:
                self.state = 83
                self.match(persephoneParser.SEPARATOR)
                self.state = 84
                self.match(persephoneParser.VAR)
                self.state = 89
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 90
            self.match(persephoneParser.RPAREN)
            self.state = 91
            self.match(persephoneParser.EQUAL)
            self.state = 92
            self.formula()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Game_playContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PLAY(self):
            return self.getToken(persephoneParser.PLAY, 0)

        def PRED_CONST(self):
            return self.getToken(persephoneParser.PRED_CONST, 0)

        def LPAREN(self):
            return self.getToken(persephoneParser.LPAREN, 0)

        def term(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(persephoneParser.TermContext)
            else:
                return self.getTypedRuleContext(persephoneParser.TermContext,i)


        def RPAREN(self):
            return self.getToken(persephoneParser.RPAREN, 0)

        def SEPARATOR(self, i:int=None):
            if i is None:
                return self.getTokens(persephoneParser.SEPARATOR)
            else:
                return self.getToken(persephoneParser.SEPARATOR, i)

        def getRuleIndex(self):
            return persephoneParser.RULE_game_play

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGame_play" ):
                listener.enterGame_play(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGame_play" ):
                listener.exitGame_play(self)




    def game_play(self):

        localctx = persephoneParser.Game_playContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_game_play)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 94
            self.match(persephoneParser.PLAY)
            self.state = 95
            self.match(persephoneParser.PRED_CONST)
            self.state = 96
            self.match(persephoneParser.LPAREN)
            self.state = 97
            self.term()
            self.state = 102
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==persephoneParser.SEPARATOR:
                self.state = 98
                self.match(persephoneParser.SEPARATOR)
                self.state = 99
                self.term()
                self.state = 104
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 105
            self.match(persephoneParser.RPAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FormulaContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def quantifier(self):
            return self.getTypedRuleContext(persephoneParser.QuantifierContext,0)


        def LPAREN(self):
            return self.getToken(persephoneParser.LPAREN, 0)

        def VAR(self):
            return self.getToken(persephoneParser.VAR, 0)

        def SEPARATOR(self, i:int=None):
            if i is None:
                return self.getTokens(persephoneParser.SEPARATOR)
            else:
                return self.getToken(persephoneParser.SEPARATOR, i)

        def domain(self):
            return self.getTypedRuleContext(persephoneParser.DomainContext,0)


        def formula(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(persephoneParser.FormulaContext)
            else:
                return self.getTypedRuleContext(persephoneParser.FormulaContext,i)


        def RPAREN(self):
            return self.getToken(persephoneParser.RPAREN, 0)

        def bin_op(self):
            return self.getTypedRuleContext(persephoneParser.Bin_opContext,0)


        def NOT(self):
            return self.getToken(persephoneParser.NOT, 0)

        def PRED_CONST(self):
            return self.getToken(persephoneParser.PRED_CONST, 0)

        def term(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(persephoneParser.TermContext)
            else:
                return self.getTypedRuleContext(persephoneParser.TermContext,i)


        def ITE(self):
            return self.getToken(persephoneParser.ITE, 0)

        def cond(self):
            return self.getTypedRuleContext(persephoneParser.CondContext,0)


        def TRUE(self):
            return self.getToken(persephoneParser.TRUE, 0)

        def FALSE(self):
            return self.getToken(persephoneParser.FALSE, 0)

        def getRuleIndex(self):
            return persephoneParser.RULE_formula

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFormula" ):
                listener.enterFormula(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFormula" ):
                listener.exitFormula(self)




    def formula(self):

        localctx = persephoneParser.FormulaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_formula)
        self._la = 0 # Token type
        try:
            self.state = 151
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [persephoneParser.FORALL, persephoneParser.EXISTS]:
                self.enterOuterAlt(localctx, 1)
                self.state = 107
                self.quantifier()
                self.state = 108
                self.match(persephoneParser.LPAREN)
                self.state = 109
                self.match(persephoneParser.VAR)
                self.state = 110
                self.match(persephoneParser.SEPARATOR)
                self.state = 111
                self.domain()
                self.state = 112
                self.match(persephoneParser.SEPARATOR)
                self.state = 113
                self.formula()
                self.state = 114
                self.match(persephoneParser.RPAREN)
                pass
            elif token in [persephoneParser.OR, persephoneParser.AND]:
                self.enterOuterAlt(localctx, 2)
                self.state = 116
                self.bin_op()
                self.state = 117
                self.match(persephoneParser.LPAREN)
                self.state = 118
                self.formula()
                self.state = 119
                self.match(persephoneParser.SEPARATOR)
                self.state = 120
                self.formula()
                self.state = 121
                self.match(persephoneParser.RPAREN)
                pass
            elif token in [persephoneParser.NOT]:
                self.enterOuterAlt(localctx, 3)
                self.state = 123
                self.match(persephoneParser.NOT)
                self.state = 124
                self.match(persephoneParser.LPAREN)
                self.state = 125
                self.formula()
                self.state = 126
                self.match(persephoneParser.RPAREN)
                pass
            elif token in [persephoneParser.PRED_CONST]:
                self.enterOuterAlt(localctx, 4)
                self.state = 128
                self.match(persephoneParser.PRED_CONST)
                self.state = 129
                self.match(persephoneParser.LPAREN)
                self.state = 130
                self.term()
                self.state = 135
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==persephoneParser.SEPARATOR:
                    self.state = 131
                    self.match(persephoneParser.SEPARATOR)
                    self.state = 132
                    self.term()
                    self.state = 137
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 138
                self.match(persephoneParser.RPAREN)
                pass
            elif token in [persephoneParser.ITE]:
                self.enterOuterAlt(localctx, 5)
                self.state = 140
                self.match(persephoneParser.ITE)
                self.state = 141
                self.match(persephoneParser.LPAREN)
                self.state = 142
                self.cond()
                self.state = 143
                self.match(persephoneParser.SEPARATOR)
                self.state = 144
                self.formula()
                self.state = 145
                self.match(persephoneParser.SEPARATOR)
                self.state = 146
                self.formula()
                self.state = 147
                self.match(persephoneParser.RPAREN)
                pass
            elif token in [persephoneParser.TRUE]:
                self.enterOuterAlt(localctx, 6)
                self.state = 149
                self.match(persephoneParser.TRUE)
                pass
            elif token in [persephoneParser.FALSE]:
                self.enterOuterAlt(localctx, 7)
                self.state = 150
                self.match(persephoneParser.FALSE)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DomainContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DOM(self):
            return self.getToken(persephoneParser.DOM, 0)

        def LPAREN(self):
            return self.getToken(persephoneParser.LPAREN, 0)

        def term(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(persephoneParser.TermContext)
            else:
                return self.getTypedRuleContext(persephoneParser.TermContext,i)


        def SEPARATOR(self):
            return self.getToken(persephoneParser.SEPARATOR, 0)

        def RPAREN(self):
            return self.getToken(persephoneParser.RPAREN, 0)

        def getRuleIndex(self):
            return persephoneParser.RULE_domain

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDomain" ):
                listener.enterDomain(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDomain" ):
                listener.exitDomain(self)




    def domain(self):

        localctx = persephoneParser.DomainContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_domain)
        try:
            self.state = 161
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [persephoneParser.DOM]:
                self.enterOuterAlt(localctx, 1)
                self.state = 153
                self.match(persephoneParser.DOM)
                self.state = 154
                self.match(persephoneParser.LPAREN)
                self.state = 155
                self.term()
                self.state = 156
                self.match(persephoneParser.SEPARATOR)
                self.state = 157
                self.term()
                self.state = 158
                self.match(persephoneParser.RPAREN)
                pass
            elif token in [persephoneParser.T__0]:
                self.enterOuterAlt(localctx, 2)
                self.state = 160
                self.match(persephoneParser.T__0)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CondContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def comp_op(self):
            return self.getTypedRuleContext(persephoneParser.Comp_opContext,0)


        def LPAREN(self):
            return self.getToken(persephoneParser.LPAREN, 0)

        def term(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(persephoneParser.TermContext)
            else:
                return self.getTypedRuleContext(persephoneParser.TermContext,i)


        def SEPARATOR(self):
            return self.getToken(persephoneParser.SEPARATOR, 0)

        def RPAREN(self):
            return self.getToken(persephoneParser.RPAREN, 0)

        def alg_bin_op(self):
            return self.getTypedRuleContext(persephoneParser.Alg_bin_opContext,0)


        def cond(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(persephoneParser.CondContext)
            else:
                return self.getTypedRuleContext(persephoneParser.CondContext,i)


        def getRuleIndex(self):
            return persephoneParser.RULE_cond

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCond" ):
                listener.enterCond(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCond" ):
                listener.exitCond(self)




    def cond(self):

        localctx = persephoneParser.CondContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_cond)
        try:
            self.state = 177
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [persephoneParser.EQ, persephoneParser.GE, persephoneParser.LE, persephoneParser.GT, persephoneParser.LS]:
                self.enterOuterAlt(localctx, 1)
                self.state = 163
                self.comp_op()
                self.state = 164
                self.match(persephoneParser.LPAREN)
                self.state = 165
                self.term()
                self.state = 166
                self.match(persephoneParser.SEPARATOR)
                self.state = 167
                self.term()
                self.state = 168
                self.match(persephoneParser.RPAREN)
                pass
            elif token in [persephoneParser.OR, persephoneParser.AND]:
                self.enterOuterAlt(localctx, 2)
                self.state = 170
                self.alg_bin_op()
                self.state = 171
                self.match(persephoneParser.LPAREN)
                self.state = 172
                self.cond()
                self.state = 173
                self.match(persephoneParser.SEPARATOR)
                self.state = 174
                self.cond()
                self.state = 175
                self.match(persephoneParser.RPAREN)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Alg_bin_opContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AND(self):
            return self.getToken(persephoneParser.AND, 0)

        def OR(self):
            return self.getToken(persephoneParser.OR, 0)

        def getRuleIndex(self):
            return persephoneParser.RULE_alg_bin_op

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlg_bin_op" ):
                listener.enterAlg_bin_op(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlg_bin_op" ):
                listener.exitAlg_bin_op(self)




    def alg_bin_op(self):

        localctx = persephoneParser.Alg_bin_opContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_alg_bin_op)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 179
            _la = self._input.LA(1)
            if not(_la==persephoneParser.OR or _la==persephoneParser.AND):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Comp_opContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EQ(self):
            return self.getToken(persephoneParser.EQ, 0)

        def GE(self):
            return self.getToken(persephoneParser.GE, 0)

        def LE(self):
            return self.getToken(persephoneParser.LE, 0)

        def GT(self):
            return self.getToken(persephoneParser.GT, 0)

        def LS(self):
            return self.getToken(persephoneParser.LS, 0)

        def getRuleIndex(self):
            return persephoneParser.RULE_comp_op

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComp_op" ):
                listener.enterComp_op(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComp_op" ):
                listener.exitComp_op(self)




    def comp_op(self):

        localctx = persephoneParser.Comp_opContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_comp_op)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 181
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << persephoneParser.EQ) | (1 << persephoneParser.GE) | (1 << persephoneParser.LE) | (1 << persephoneParser.GT) | (1 << persephoneParser.LS))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TermContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUM(self):
            return self.getToken(persephoneParser.NUM, 0)

        def VAR(self, i:int=None):
            if i is None:
                return self.getTokens(persephoneParser.VAR)
            else:
                return self.getToken(persephoneParser.VAR, i)

        def LPAREN(self):
            return self.getToken(persephoneParser.LPAREN, 0)

        def RPAREN(self):
            return self.getToken(persephoneParser.RPAREN, 0)

        def algebra(self):
            return self.getTypedRuleContext(persephoneParser.AlgebraContext,0)


        def term(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(persephoneParser.TermContext)
            else:
                return self.getTypedRuleContext(persephoneParser.TermContext,i)


        def SEPARATOR(self):
            return self.getToken(persephoneParser.SEPARATOR, 0)

        def getRuleIndex(self):
            return persephoneParser.RULE_term

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTerm" ):
                listener.enterTerm(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTerm" ):
                listener.exitTerm(self)




    def term(self):

        localctx = persephoneParser.TermContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_term)
        self._la = 0 # Token type
        try:
            self.state = 199
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [persephoneParser.NUM]:
                self.enterOuterAlt(localctx, 1)
                self.state = 183
                self.match(persephoneParser.NUM)
                pass
            elif token in [persephoneParser.VAR]:
                self.enterOuterAlt(localctx, 2)
                self.state = 184
                self.match(persephoneParser.VAR)
                self.state = 190
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==persephoneParser.LPAREN:
                    self.state = 185
                    self.match(persephoneParser.LPAREN)
                    self.state = 187
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==persephoneParser.VAR:
                        self.state = 186
                        self.match(persephoneParser.VAR)


                    self.state = 189
                    self.match(persephoneParser.RPAREN)


                pass
            elif token in [persephoneParser.Add, persephoneParser.Sub]:
                self.enterOuterAlt(localctx, 3)
                self.state = 192
                self.algebra()
                self.state = 193
                self.match(persephoneParser.LPAREN)
                self.state = 194
                self.term()
                self.state = 195
                self.match(persephoneParser.SEPARATOR)
                self.state = 196
                self.term()
                self.state = 197
                self.match(persephoneParser.RPAREN)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AlgebraContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Add(self):
            return self.getToken(persephoneParser.Add, 0)

        def Sub(self):
            return self.getToken(persephoneParser.Sub, 0)

        def getRuleIndex(self):
            return persephoneParser.RULE_algebra

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlgebra" ):
                listener.enterAlgebra(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlgebra" ):
                listener.exitAlgebra(self)




    def algebra(self):

        localctx = persephoneParser.AlgebraContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_algebra)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 201
            _la = self._input.LA(1)
            if not(_la==persephoneParser.Add or _la==persephoneParser.Sub):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QuantifierContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EXISTS(self):
            return self.getToken(persephoneParser.EXISTS, 0)

        def FORALL(self):
            return self.getToken(persephoneParser.FORALL, 0)

        def getRuleIndex(self):
            return persephoneParser.RULE_quantifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQuantifier" ):
                listener.enterQuantifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQuantifier" ):
                listener.exitQuantifier(self)




    def quantifier(self):

        localctx = persephoneParser.QuantifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_quantifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 203
            _la = self._input.LA(1)
            if not(_la==persephoneParser.FORALL or _la==persephoneParser.EXISTS):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Bin_opContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AND(self):
            return self.getToken(persephoneParser.AND, 0)

        def OR(self):
            return self.getToken(persephoneParser.OR, 0)

        def getRuleIndex(self):
            return persephoneParser.RULE_bin_op

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBin_op" ):
                listener.enterBin_op(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBin_op" ):
                listener.exitBin_op(self)




    def bin_op(self):

        localctx = persephoneParser.Bin_opContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_bin_op)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 205
            _la = self._input.LA(1)
            if not(_la==persephoneParser.OR or _la==persephoneParser.AND):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





